import { SideEffect2, Function1, Updater } from "./functions.mjs";
import { IOSourceLike, IOSourceOperator } from "./io.mjs";
import { ReadonlyObjectMap } from "./readonlyObjectMap.mjs";
declare const HttpStandardHeaders: {
    readonly Accept: "Accept";
    readonly AcceptCharset: "Accept-Charset";
    readonly AcceptEncoding: "Accept-Encoding";
    readonly AcceptLanguage: "Accept-Language";
    readonly AcceptRanges: "Accept-Ranges";
    readonly Age: "Age";
    readonly Allow: "Allow";
    readonly Authorization: "Authorization";
    readonly CacheControl: "Cache-Control";
    readonly Connection: "Connection";
    readonly ContentEncoding: "Content-Encoding";
    readonly ContentLanguage: "Content-Language";
    readonly ContentLength: "Content-Length";
    readonly ContentLocation: "Content-Location";
    readonly ContentMD5: "Content-MD5";
    readonly ContentRange: "Content-Range";
    readonly ContentType: "Content-Type";
    readonly Cookie: "Cookie";
    readonly Date: "Date";
    readonly ETag: "ETag";
    readonly Expect: "Expect";
    readonly Expires: "Expires";
    readonly From: "From";
    readonly Host: "Host";
    readonly IfMatch: "If-Match";
    readonly IfModifiedSince: "If-Modified-Since";
    readonly IfNoneMatch: "If-None-Match";
    readonly IfRange: "If-Range";
    readonly IfUnmodifiedSince: "If-Unmodified-Since";
    readonly LastModified: "Last-Modified";
    readonly Location: "Location";
    readonly MaxForwards: "Max-Forwards";
    readonly Pragma: "Pragma";
    readonly ProxyAuthenticate: "Proxy-Authenticate";
    readonly ProxyAuthorization: "Proxy-Authorization";
    readonly Range: "Range";
    readonly Referer: "Referer";
    readonly RetryAfter: "Retry-After";
    readonly Server: "Server";
    readonly SetCookie: "Set-Cookie";
    readonly TE: "TE";
    readonly Trailer: "Trailer";
    readonly TransferEncoding: "Transfer-Encoding";
    readonly Upgrade: "Upgrade";
    readonly UserAgent: "User-Agent";
    readonly Vary: "Vary";
    readonly Via: "Via";
    readonly Warning: "Warning";
    readonly WWWAuthenticate: "WWW-Authenticate";
};
declare const HttpExtensionHeaders: {
    XForwardedProto: string;
    XForwardedHost: string;
    XHttpMethod: string;
    XHttpMethodOverride: string;
    XMethodOverride: string;
};
declare const HttpStatusCodes: {
    readonly Continue: 100;
    readonly SwitchingProtocols: 101;
    readonly Processing: 102;
    readonly OK: 200;
    readonly Created: 201;
    readonly Accepted: 202;
    readonly NonAuthoritativeInformation: 203;
    readonly NoContent: 204;
    readonly ResetContent: 205;
    readonly PartialContent: 206;
    readonly MultiStatus: 207;
    readonly AlreadyReported: 208;
    readonly IMUsed: 226;
    readonly MultipleChoices: 300;
    readonly MovedPermanently: 301;
    readonly Found: 302;
    readonly SeeOther: 303;
    readonly NotModified: 304;
    readonly UseProxy: 305;
    readonly TemporaryRedirect: 307;
    readonly PermanentRedirect: 308;
    readonly BadRequest: 400;
    readonly Unauthorized: 401;
    readonly Forbidden: 403;
    readonly NotFound: 404;
    readonly MethodNotAllowed: 405;
    readonly NotAcceptable: 406;
    readonly ProxyAuthenticationRequired: 407;
    readonly RequestTimeout: 408;
    readonly Conflict: 409;
    readonly Gone: 410;
    readonly LengthRequired: 411;
    readonly PreconditionFailed: 412;
    readonly RequestEntityTooLarge: 413;
    readonly RequestURITooLong: 414;
    readonly UnsupportedMediaType: 415;
    readonly RequestedRangeNotSatisfiable: 416;
    readonly ExpectationFailed: 417;
    readonly UnprocessableEntity: 422;
    readonly Locked: 423;
    readonly FailedDependency: 424;
    readonly UpgradeRequired: 426;
    readonly PreconditionRequired: 428;
    readonly TooManyRequests: 429;
    readonly RequestHeaderFieldsTooLarge: 431;
    readonly UnavailableForLegalReasons: 451;
    readonly InternalServerError: 500;
    readonly NotImplemented: 501;
    readonly BadGateway: 502;
    readonly ServiceUnavailable: 503;
    readonly GatewayTimeout: 504;
    readonly HTTPVersionNotSupported: 505;
    readonly VariantAlsoNegotiates: 506;
    readonly InsufficientStorage: 507;
    readonly LoopDetected: 508;
    readonly NotExtended: 510;
    readonly NetworkAuthenticationRequired: 511;
};
declare const createHttpResponse: <T>({ etag, expires, headers, lastModified, location, statusCode, vary, ...rest }: HttpResponseOptions<T>) => HttpResponse<T>;
declare const writeHttpResponseHeaders: <T>(response: HttpResponse<T>, writeHeader: SideEffect2<string, string>) => void;
declare const checkIfNotModified: <T>({ cacheControl, method, preconditions, }: HttpRequest<unknown>) => Function1<HttpResponse<T>, HttpResponse<T>>;
declare const encodeHttpResponseWithUtf8: Function1<HttpResponse<string>, HttpResponse<Uint8Array>>;
declare const decodeHttpResponseWithCharset: Function1<HttpResponse<Uint8Array>, HttpResponse<string>>;
declare const toIOSourceHttpResponse: <TBody>(resp: HttpResponse<TBody>) => HttpResponse<IOSourceLike<TBody>>;
declare const decodeHttpResponseContent: (decoderProvider: ReadonlyObjectMap<IOSourceOperator<Uint8Array, Uint8Array>>) => Function1<HttpResponse<IOSourceLike<Uint8Array>>, HttpResponse<IOSourceLike<Uint8Array>>>;
declare const encodeHttpResponseContent: (encoderProvider: ReadonlyObjectMap<IOSourceOperator<Uint8Array, Uint8Array>>, db?: ReadonlyObjectMap<{
    compressible?: boolean;
}>) => Function1<HttpRequest<unknown>, Updater<HttpResponse<IOSourceLike<Uint8Array>>>>;
declare const createHttpErrorResponse: (e: unknown) => HttpResponse<unknown>;
declare const createRedirectHttpRequest: <THttpRequest extends HttpRequest<TReq>, TReq>(request: THttpRequest, response: HttpResponse<unknown>) => THttpRequest;
declare const decodeHttpRequestContent: (decoderProvider: ReadonlyObjectMap<IOSourceOperator<Uint8Array, Uint8Array>>) => Function1<HttpRequest<IOSourceLike<Uint8Array>>, HttpRequest<IOSourceLike<Uint8Array>>>;
declare const createHttpRequest: <T>(options: HttpRequestOptions<T>) => HttpRequest<T>;
declare const disallowProtocolAndHostForwarding: <T>() => Function1<HttpRequest<T>, HttpRequest<T>>;
declare const writeHttpRequestHeaders: <T>(request: HttpRequest<T>, writeHeader: SideEffect2<string, string>) => void;
declare const encodeHttpRequestWithUtf8: Function1<HttpRequest<string>, HttpRequest<Uint8Array>>;
declare const decodeHttpRequestWithCharset: Function1<HttpRequest<Uint8Array>, HttpRequest<string>>;
declare const toIOSourceHttpRequest: <TBody>(req: HttpRequest<TBody>) => HttpRequest<IOSourceLike<TBody>>;
declare type CacheDirective = {
    readonly directive: string;
    readonly value: string;
};
declare type EntityTag = {
    readonly isWeak: boolean;
    readonly tag: string;
};
declare type HttpContentEncoding = "br" | "compress" | "deflate" | "gzip" | "identify";
declare type MediaType = {
    readonly type: string;
    readonly subtype: string;
    readonly params: ReadonlyObjectMap<string>;
};
declare type HttpContentInfo = {
    readonly contentEncodings: readonly HttpContentEncoding[];
    readonly contentLength: number;
    readonly contentType: MediaType;
};
declare type HttpDateTime = number;
declare type HttpHeaders = ReadonlyObjectMap<string>;
declare type HttpStandardHeadersKeys = keyof typeof HttpStandardHeaders;
declare type HttpStandardHeader = typeof HttpStandardHeaders[HttpStandardHeadersKeys];
declare type HttpExtensionHeadersKeys = keyof typeof HttpExtensionHeaders;
declare type HttpExtensionHeader = typeof HttpExtensionHeaders[HttpExtensionHeadersKeys];
interface URILike {
    readonly hash: string;
    readonly host: string;
    readonly hostname: string;
    readonly href: string;
    readonly origin: string;
    readonly pathname: string;
    readonly port: string;
    readonly protocol: string;
    readonly search: string;
    toString(): string;
}
declare type MediaRange = {
    readonly type: string | "*";
    readonly subtype: string | "*";
};
declare type HttpPreferences = {
    readonly acceptedCharsets: readonly string[];
    readonly acceptedEncodings: readonly HttpContentEncoding[];
    readonly acceptedLanguages: readonly string[];
    readonly acceptedMediaRanges: readonly MediaRange[];
};
declare type HttpMessage<T> = {
    readonly body: T;
    readonly cacheControl: readonly CacheDirective[];
    readonly contentInfo?: HttpContentInfo;
    readonly headers: HttpHeaders;
    readonly preferences?: HttpPreferences;
};
declare type HttpMessageOptions<T> = {
    body: T;
    cacheControl?: readonly (string | CacheDirective)[];
    contentInfo?: {
        readonly contentEncodings?: readonly HttpContentEncoding[];
        readonly contentLength?: number;
        readonly contentType: MediaType | string;
    };
    headers?: HttpHeaders;
    preferences?: {
        readonly acceptedCharsets?: readonly string[];
        readonly acceptedEncodings?: readonly HttpContentEncoding[];
        readonly acceptedLanguages?: readonly string[];
        readonly acceptedMediaRanges?: readonly (string | MediaRange)[];
    };
};
declare type HttpMethod = "GET" | "HEAD" | "POST" | "PUT" | "DELETE";
declare type HttpRequestPreconditions = {
    readonly ifMatch?: readonly EntityTag[] | "*";
    readonly ifModifiedSince?: HttpDateTime;
    readonly ifNoneMatch?: readonly EntityTag[] | "*";
    readonly ifUnmodifiedSince?: HttpDateTime;
    readonly ifRange?: EntityTag | HttpDateTime;
};
declare type HttpRequest<T> = HttpMessage<T> & {
    readonly expectContinue: boolean;
    readonly method: HttpMethod;
    readonly preconditions?: HttpRequestPreconditions;
    readonly uri: URILike;
    readonly httpVersionMajor: number;
    readonly httpVersionMinor: number;
    readonly isTransportSecure: boolean;
};
declare type HttpRequestOptions<T> = HttpMessageOptions<T> & {
    readonly expectContinue?: boolean;
    readonly headers?: HttpHeaders;
    readonly httpVersionMajor?: number;
    readonly httpVersionMinor?: number;
    readonly isTransportSecure?: boolean;
    readonly method: HttpMethod;
    readonly preconditions?: {
        readonly ifMatch?: readonly (string | EntityTag)[] | "*";
        readonly ifModifiedSince?: string | HttpDateTime | Date;
        readonly ifNoneMatch?: readonly (string | EntityTag)[] | "*";
        readonly ifUnmodifiedSince?: string | HttpDateTime | Date;
        readonly ifRange?: string | EntityTag | HttpDateTime | Date;
    };
    readonly uri: string | URILike;
};
declare type HttpStatusCodesKeys = keyof typeof HttpStatusCodes;
declare type HttpStatusCode = typeof HttpStatusCodes[HttpStatusCodesKeys];
declare type HttpResponse<T> = HttpMessage<T> & {
    readonly etag?: EntityTag;
    readonly expires?: HttpDateTime;
    readonly lastModified?: HttpDateTime;
    readonly location?: URILike;
    readonly statusCode: HttpStatusCode;
    readonly vary: readonly string[];
};
declare type HttpResponseOptions<T> = HttpMessageOptions<T> & {
    readonly etag?: string | EntityTag;
    readonly expires?: number | string | Date;
    readonly headers?: HttpHeaders;
    readonly lastModified?: number | string | Date;
    readonly location?: string | URILike;
    readonly statusCode: HttpStatusCode;
    readonly vary?: readonly string[];
};
export { CacheDirective, EntityTag, HttpContentEncoding, HttpContentInfo, HttpDateTime, HttpExtensionHeader, HttpExtensionHeaders, HttpHeaders, HttpMessage, HttpMessageOptions, HttpMethod, HttpPreferences, HttpRequest, HttpRequestOptions, HttpRequestPreconditions, HttpResponse, HttpResponseOptions, HttpStandardHeader, HttpStandardHeaders, HttpStatusCode, HttpStatusCodes, MediaRange, MediaType, URILike, checkIfNotModified, createHttpErrorResponse, createHttpRequest, createHttpResponse, createRedirectHttpRequest, decodeHttpRequestContent, decodeHttpRequestWithCharset, decodeHttpResponseContent, decodeHttpResponseWithCharset, disallowProtocolAndHostForwarding, encodeHttpRequestWithUtf8, encodeHttpResponseContent, encodeHttpResponseWithUtf8, toIOSourceHttpRequest, toIOSourceHttpResponse, writeHttpRequestHeaders, writeHttpResponseHeaders };
